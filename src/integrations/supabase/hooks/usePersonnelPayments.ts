import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { supabase } from "../client";
import { toast } from "sonner";

export type PersonnelPaymentType = "regular" | "bonus" | "reimbursement" | "advance";

export interface PersonnelPaymentAllocation {
  id?: string;
  payment_id?: string;
  project_id: string;
  amount: number;
  notes: string | null;
}

export interface PersonnelPayment {
  id: string;
  number: string;
  personnel_id: string;
  personnel_name: string;
  payment_date: string;
  gross_amount: number;
  category_id: string | null;
  payment_type: PersonnelPaymentType;
  notes: string | null;
  created_at: string;
  updated_at: string;
  allocations?: PersonnelPaymentAllocation[];
}

export interface PersonnelPaymentFilters {
  personnel_id?: string;
  project_id?: string;
  category_id?: string;
  payment_type?: PersonnelPaymentType;
  start_date?: string;
  end_date?: string;
}

export const usePersonnelPayments = (filters?: PersonnelPaymentFilters) => {
  return useQuery({
    queryKey: ["personnel-payments", filters],
    queryFn: async () => {
      let query = supabase
        .from("personnel_payments")
        .select("*")
        .order("created_at", { ascending: false });

      if (filters?.personnel_id) {
        query = query.eq("personnel_id", filters.personnel_id);
      }
      if (filters?.category_id) {
        query = query.eq("category_id", filters.category_id);
      }
      if (filters?.payment_type) {
        query = query.eq("payment_type", filters.payment_type);
      }
      if (filters?.start_date) {
        query = query.gte("payment_date", filters.start_date);
      }
      if (filters?.end_date) {
        query = query.lte("payment_date", filters.end_date);
      }

      const { data, error } = await query;
      if (error) throw error;

      // If filtering by project, we need to filter by allocations
      if (filters?.project_id) {
        const { data: allocations, error: allocError } = await supabase
          .from("personnel_payment_allocations")
          .select("payment_id")
          .eq("project_id", filters.project_id);

        if (allocError) throw allocError;
        const paymentIds = [...new Set(allocations.map(a => a.payment_id))];
        return (data as PersonnelPayment[]).filter(payment => paymentIds.includes(payment.id));
      }

      return data as PersonnelPayment[];
    },
  });
};

export const usePersonnelPayment = (id: string | undefined) => {
  return useQuery({
    queryKey: ["personnel-payment", id],
    queryFn: async () => {
      if (!id) return null;

      const { data: payment, error: paymentError } = await supabase
        .from("personnel_payments")
        .select("*")
        .eq("id", id)
        .maybeSingle();

      if (paymentError) throw paymentError;
      if (!payment) return null;

      const { data: allocations, error: allocError } = await supabase
        .from("personnel_payment_allocations")
        .select("*")
        .eq("payment_id", id);

      if (allocError) throw allocError;

      return {
        ...payment,
        allocations: allocations,
      } as PersonnelPayment;
    },
    enabled: !!id,
  });
};

export const usePersonnelPaymentsByProject = (projectId: string | undefined) => {
  return useQuery({
    queryKey: ["personnel-payments-by-project", projectId],
    queryFn: async () => {
      if (!projectId) return [];

      const { data: allocations, error: allocError } = await supabase
        .from("personnel_payment_allocations")
        .select("payment_id, amount, personnel_payments(*)")
        .eq("project_id", projectId);

      if (allocError) throw allocError;

      return allocations.map((item: any) => ({
        payment: item.personnel_payments,
        allocated_amount: Number(item.amount),
      }));
    },
    enabled: !!projectId,
  });
};

export const useAddPersonnelPayment = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      payment,
      allocations,
    }: {
      payment: Omit<PersonnelPayment, "id" | "number" | "created_at" | "updated_at" | "allocations">;
      allocations: Omit<PersonnelPaymentAllocation, "id" | "payment_id">[];
    }) => {
      // Insert payment (number auto-generated by trigger)
      const { data: newPayment, error: paymentError } = await supabase
        .from("personnel_payments")
        .insert([{
          personnel_id: payment.personnel_id,
          personnel_name: payment.personnel_name,
          payment_date: payment.payment_date,
          gross_amount: payment.gross_amount,
          category_id: payment.category_id,
          payment_type: payment.payment_type,
          notes: payment.notes,
          number: "", // Will be auto-generated by trigger
        }])
        .select()
        .single();

      if (paymentError) throw paymentError;

      // Insert allocations
      if (allocations.length > 0) {
        const { error: allocError } = await supabase
          .from("personnel_payment_allocations")
          .insert(allocations.map(alloc => ({
            ...alloc,
            payment_id: newPayment.id,
          })));

        if (allocError) throw allocError;
      }

      return newPayment;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["personnel-payments"] });
      toast.success("Personnel payment created successfully");
    },
    onError: (error: Error) => {
      toast.error(`Failed to create personnel payment: ${error.message}`);
    },
  });
};

export const useUpdatePersonnelPayment = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      id,
      payment,
      allocations,
    }: {
      id: string;
      payment: Partial<PersonnelPayment>;
      allocations: Omit<PersonnelPaymentAllocation, "id" | "payment_id">[];
    }) => {
      // Update payment
      const { error: paymentError } = await supabase
        .from("personnel_payments")
        .update({
          personnel_id: payment.personnel_id,
          personnel_name: payment.personnel_name,
          payment_date: payment.payment_date,
          gross_amount: payment.gross_amount,
          category_id: payment.category_id,
          payment_type: payment.payment_type,
          notes: payment.notes,
        })
        .eq("id", id);

      if (paymentError) throw paymentError;

      // Delete existing allocations and re-insert
      const { error: deleteError } = await supabase
        .from("personnel_payment_allocations")
        .delete()
        .eq("payment_id", id);

      if (deleteError) throw deleteError;

      if (allocations.length > 0) {
        const { error: allocError } = await supabase
          .from("personnel_payment_allocations")
          .insert(allocations.map(alloc => ({
            ...alloc,
            payment_id: id,
          })));

        if (allocError) throw allocError;
      }

      return id;
    },
    onSuccess: (id) => {
      queryClient.invalidateQueries({ queryKey: ["personnel-payments"] });
      queryClient.invalidateQueries({ queryKey: ["personnel-payment", id] });
      toast.success("Personnel payment updated successfully");
    },
    onError: (error: Error) => {
      toast.error(`Failed to update personnel payment: ${error.message}`);
    },
  });
};

export const useDeletePersonnelPayment = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (id: string) => {
      const { error } = await supabase
        .from("personnel_payments")
        .delete()
        .eq("id", id);

      if (error) throw error;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["personnel-payments"] });
      toast.success("Personnel payment deleted successfully");
    },
    onError: (error: Error) => {
      toast.error(`Failed to delete personnel payment: ${error.message}`);
    },
  });
};
